{"remainingRequest":"/home/alphabat69/WorkSpace/GitHub Repositories/MEAN-Stack-Training/Assignment_6/GOF/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/alphabat69/WorkSpace/GitHub Repositories/MEAN-Stack-Training/Assignment_6/GOF/node_modules/angular-svg-round-progressbar/dist/round-progress.service.js","dependencies":[{"path":"/home/alphabat69/WorkSpace/GitHub Repositories/MEAN-Stack-Training/Assignment_6/GOF/node_modules/angular-svg-round-progressbar/dist/round-progress.service.js","mtime":499162500000},{"path":"/home/alphabat69/WorkSpace/GitHub Repositories/MEAN-Stack-Training/Assignment_6/GOF/node_modules/cache-loader/dist/cjs.js","mtime":1529607850724},{"path":"/home/alphabat69/WorkSpace/GitHub Repositories/MEAN-Stack-Training/Assignment_6/GOF/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar platform_browser_1 = require(\"@angular/platform-browser\");\nvar DEGREE_IN_RADIANS = Math.PI / 180;\nvar RoundProgressService = /** @class */ /*@__PURE__*/ (function () {\n    function RoundProgressService(document) {\n        this.supportsSvg = !!(document &&\n            document.createElementNS &&\n            document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);\n        this._base = document && document.head.querySelector('base');\n        this._hasPerf = typeof window !== 'undefined' &&\n            window.performance &&\n            window.performance.now &&\n            typeof window.performance.now() === 'number';\n    }\n    /**\n     * Resolves a SVG color against the page's `base` tag.\n     */\n    /**\n       * Resolves a SVG color against the page's `base` tag.\n       */\n    RoundProgressService.prototype.resolveColor = /**\n       * Resolves a SVG color against the page's `base` tag.\n       */\n        function (color) {\n            if (this._base && this._base.href) {\n                var hashIndex = color.indexOf('#');\n                if (hashIndex > -1 && color.indexOf('url') > -1) {\n                    return color.slice(0, hashIndex) + location.href + color.slice(hashIndex);\n                }\n            }\n            return color;\n        };\n    /**\n     * Generates a timestamp.\n     */\n    /**\n       * Generates a timestamp.\n       */\n    RoundProgressService.prototype.getTimestamp = /**\n       * Generates a timestamp.\n       */\n        function () {\n            return this._hasPerf ? window.performance.now() : Date.now();\n        };\n    /**\n     * Generates the value for an SVG arc.\n     * @param current       Current value.\n     * @param total         Maximum value.\n     * @param pathRadius    Radius of the SVG path.\n     * @param elementRadius Radius of the SVG container.\n     * @param isSemicircle  Whether the element should be a semicircle.\n     */\n    /**\n       * Generates the value for an SVG arc.\n       * @param current       Current value.\n       * @param total         Maximum value.\n       * @param pathRadius    Radius of the SVG path.\n       * @param elementRadius Radius of the SVG container.\n       * @param isSemicircle  Whether the element should be a semicircle.\n       */\n    RoundProgressService.prototype.getArc = /**\n       * Generates the value for an SVG arc.\n       * @param current       Current value.\n       * @param total         Maximum value.\n       * @param pathRadius    Radius of the SVG path.\n       * @param elementRadius Radius of the SVG container.\n       * @param isSemicircle  Whether the element should be a semicircle.\n       */\n        function (current, total, pathRadius, elementRadius, isSemicircle) {\n            if (isSemicircle === void 0) {\n                isSemicircle = false;\n            }\n            var value = Math.max(0, Math.min(current || 0, total));\n            var maxAngle = isSemicircle ? 180 : 359.9999;\n            var percentage = total === 0 ? maxAngle : (value / total) * maxAngle;\n            var start = this._polarToCartesian(elementRadius, pathRadius, percentage);\n            var end = this._polarToCartesian(elementRadius, pathRadius, 0);\n            var arcSweep = (percentage <= 180 ? 0 : 1);\n            return \"M \" + start + \" A \" + pathRadius + \" \" + pathRadius + \" 0 \" + arcSweep + \" 0 \" + end;\n        };\n    ;\n    /**\n     * Converts polar cooradinates to Cartesian.\n     * @param elementRadius  Radius of the wrapper element.\n     * @param pathRadius     Radius of the path being described.\n     * @param angleInDegrees Degree to be converted.\n     */\n    /**\n       * Converts polar cooradinates to Cartesian.\n       * @param elementRadius  Radius of the wrapper element.\n       * @param pathRadius     Radius of the path being described.\n       * @param angleInDegrees Degree to be converted.\n       */\n    RoundProgressService.prototype._polarToCartesian = /**\n       * Converts polar cooradinates to Cartesian.\n       * @param elementRadius  Radius of the wrapper element.\n       * @param pathRadius     Radius of the path being described.\n       * @param angleInDegrees Degree to be converted.\n       */\n        function (elementRadius, pathRadius, angleInDegrees) {\n            var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\n            var x = elementRadius + (pathRadius * Math.cos(angleInRadians));\n            var y = elementRadius + (pathRadius * Math.sin(angleInRadians));\n            return x + ' ' + y;\n        };\n    RoundProgressService.decorators = [\n        { type: core_1.Injectable },\n    ];\n    return RoundProgressService;\n}());\nexports.RoundProgressService = RoundProgressService;\n;\n",null]}